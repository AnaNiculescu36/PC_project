"0","# sigmoid"
"0","g = function (z) {"
"0","  return (1 / (1 + exp(-z) ))"
"0","} # plot(g(c(1,2,3,4,5,6)))"
"0","# hypothesis "
"0","h = function (x,th) {"
"0","  return( g(x %*% th) )"
"0","} # h(x,th)"
"0","# cost"
"0","J = function (x,y,th,m) {"
"0","  return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )"
"0","} # J(x,y,th,m)"
"0","# derivative of J (gradient)"
"0","grad = function (x,y,th,m) {"
"0","  return( 1/m * t(x) %*% (h(x, th) - y))"
"0","} # grad(x,y,th,m)"
"0","# Hessian"
"0","H = function (x,y,th,m) {"
"0","  return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))"
"0","} # H(x,y,th,m)"
"0","basic.mle <- function(x, y) {"
"0","  j = array(0, c(10,1))"
"0","  m = length(x$test1)"
"0","  # eliminate matrix, use for to see what happens to the dataframe"
"0","  x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)"
"0","  y_calc = matrix(y$admitted, ncol=1)"
"0","  th = matrix(0,3)"
"0","  for (i in 1:10) {"
"0","     #update j at every iteration and keep only the last j calculated"
"0","      j = J(x, y, th, m) # stores each iteration Cost"
"0","      th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m) "
"0","  }"
"0","  th"
"0","}"
"0","theta <- basic.mle(exam_x, exam_y)"
"0","# plot(j, xlab=""iterations"", ylab=""cost J"", type = ""l"")"
