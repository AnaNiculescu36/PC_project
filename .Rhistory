numeric(3)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x,th) - y))
} # grad(x,y,th,m)
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x,th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y = matrix(x$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:100) {
j[i] = J(x,y,th,m) # stores each iteration Cost
th = th - solve(H(x,y,th,m)) %*% grad(x,y,th,m)
}
}
j <- basic.mle(exam_x, exam_y)
y = matrix(y$admitted, ncol=1)
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x,th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:100) {
j[i] = J(x,y,th,m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
j
}
j <- basic.mle(exam_x, exam_y)
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x,th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:100) {
j[i] = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
j
}
j <- basic.mle(exam_x, exam_y)
m = length(x$test1)
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x, th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x$test1)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:100) {
j[i] = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
j
}
j <- basic.mle(exam_x, exam_y)
plot(j, xlab="iterations", ylab="cost J")
plot(j, xlab="iterations", ylab="cost J", type = "l")
for (i in 1:100 {
for (i in 1:10) {
j[i] = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x, th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x$test1)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:10) {
j[i] = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
j
}
j <- basic.mle(exam_x, exam_y)
plot(j, xlab="iterations", ylab="cost J", type = "l")
j
j[6]
j
j = J(x, y, th, m) # stores each iteration Cost
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x, th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x$test1)
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:10) {
j = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
j
}
j <- basic.mle(exam_x, exam_y)
# plot(j, xlab="iterations", ylab="cost J", type = "l")
j
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x, th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x$test1)
# eliminate matrix, use for to see what happens to the dataframe
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:10) {
#update j at every iteration and keep only the last j calculated
j = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
th
}
theta <- basic.mle(exam_x, exam_y)
# plot(j, xlab="iterations", ylab="cost J", type = "l")
theta
y_test <- theta[1] + theta[2] * 20 + theta[3] * 80
y_test
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
for (i in 1:n_folds) {
fold = 0
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- dataset[index, ]
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
for (i in 1:n_folds) {
fold = 0
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- dataset[index, ]
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
x
browser()
knitr::opts_chunk$set(echo = TRUE)
exam_x = read.delim("data/ex4x.dat", sep = " ")
exam_y = read.delim("data/ex4y.dat")
# cleaning the data
exam_x <- exam_x[ ,c(4, 7)]
colnames(exam_x) <- c("test1", "test2")
colnames(exam_y) <- "admitted"
exam_df <- dplyr::bind_cols(exam_x, exam_y)
exam_x = read.delim("data/ex4x.dat", sep = " ")
exam_y = read.delim("data/ex4y.dat")
# cleaning the data
exam_x <- exam_x[ ,c(4, 7)]
colnames(exam_x) <- c("test1", "test2")
colnames(exam_y) <- "admitted"
exam_df <- dplyr::bind_cols(exam_x, exam_y)
ggplot2::ggplot(exam_df, ggplot2::aes(x = test1, y = test2, col = as.factor(admitted))) +
ggplot2::geom_point()
# sigmoid
g = function (z) {
return (1 / (1 + exp(-z) ))
} # plot(g(c(1,2,3,4,5,6)))
# hypothesis
h = function (x,th) {
return( g(x %*% th) )
} # h(x,th)
# cost
J = function (x,y,th,m) {
return( 1/m * sum(-y * log(h(x,th)) - (1 - y) * log(1 - h(x,th))) )
} # J(x,y,th,m)
# derivative of J (gradient)
grad = function (x,y,th,m) {
return( 1/m * t(x) %*% (h(x, th) - y))
} # grad(x,y,th,m)
# Hessian
H = function (x,y,th,m) {
return (1/m * t(x) %*% x * diag(h(x,th)) * diag(1 - h(x,th)))
} # H(x,y,th,m)
basic.mle <- function(x, y) {
j = array(0, c(10,1))
m = length(x$test1)
# eliminate matrix, use for to see what happens to the dataframe
x = matrix(c(rep(1, m), x$test1, x$test2), ncol=3)
y_calc = matrix(y$admitted, ncol=1)
th = matrix(0,3)
for (i in 1:10) {
#update j at every iteration and keep only the last j calculated
j = J(x, y, th, m) # stores each iteration Cost
th = th - solve(H(x,y_calc,th,m)) %*% grad(x,y_calc,th,m)
}
th
}
theta <- basic.mle(exam_x, exam_y)
# -16.38
# 0.1483
# 0.1589
# Model = theta[1] + theta[2] * x$test1 + theta[3] * x$test_2
y_test <- theta[1] + theta[2] * 20 + theta[3] * 80
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
browser()
for (i in 1:n_folds) {
fold = 0
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- dataset[index, ]
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
dataset_split
print(dataset_split)
str(dataset_split)
index
fold_r
print(fold_r)
dataset[55, ]
str(dataset)
dataset[1. ]
dataset[1,  ]
print(dataset$test1)
print(dataset[1, ])
print(dataset[1, 1])
print(dataset[c(1:2)])
print(dataset[c(1:2),])
print(dataset[6 ,])
print(dataset[1:2,])
print(dataset[1:10,])
dataset
str(dataset)
str(dataset[which(admitted == 1),])
str(dataset[which(dataset$admitted == 1),])
str(dataset[1,])
str(dataset[55,])
str(fold_r)
fold = fold + 1
fold_r <- rbind(fold_r, dataset[index, ])
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
browser()
for (i in 1:n_folds) {
fold = data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- rbind(fold_r, dataset[index, ])
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
browser()
for (i in 1:n_folds) {
fold = data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- rbind(fold_r, dataset[index, ])
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
browser()
for (i in 1:n_folds) {
fold = data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- rbind(fold_r, dataset[index, ])
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
for (i in 1:n_folds) {
fold_r = data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- rbind(fold_r, dataset[index, ])
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
basic.cv <- function(dataset, var) {
n_folds = 4
dataset_copy <- dataset
fold_size <- as.numeric(nrow(dataset) / n_folds)
dataset_split <- data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
for (fold in 1:n_folds) {
fold_r = data.frame(test1 = numeric(),
test2 = numeric(),
admitted = logical())
while(fold < fold_size) {
index <- sample(1:nrow(dataset), 1)
fold_r <- rbind(fold_r, dataset[index, ])
fold = fold + 1
}
dataset_split <- rbind(dataset_split, fold_r)
dataset_split
}
}
x <- basic.cv(exam_df, 1)
x
browser()
