fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
sum <- 0
for(l in 1:length(thetas)) {
sum <- sum + mat_test[l] * thetas[l]
}
predicted_y[k] <- sum
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
sum <- 0
for (l in 1:length(thetas)) {
sum <- sum + mat_test[,l] * thetas[l]
}
predicted_y[k] <- sum
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
browser()
sum <- 0
for (l in 1:length(thetas)) {
sum <- sum + mat_test[,l] * thetas[l]
}
predicted_y[k] <- sum
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
sum
mat_test[,]
mat_test[,l]
mat_test[l,]
mat_test[,l]
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
browser()
sum <- 0
for (l in 1:length(thetas)) {
sum <- sum + mat_test[,l] * thetas[l]
}
predicted_y[k] <- sum
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
sum
mat_test %*% thetas
sum
mat_test %*% thetas
sum
mat_test %*% thetas
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
predicted_y[k] <- mat_test %*% thetas
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- numeric(n_folds)
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
sum <- 0
for(l in 1:length(thetas)) {
sum <- sum + mat_test[l] * thetas[l]
}
predicted_y[k] <- sum
#  predicted_y[k] <- mat_test %*% thetas
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
?nrow
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
x1 <- basic.cv2(exam_df_c, c("test1", "test2", "test3"), "admitted")
x1 <- basic.cv1(exam_df_c, c("test1", "test2", "test3"), "admitted")
set.seed(1)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x1 <- basic.cv1(exam_df_c, c("test1", "test2", "test3"), "admitted")
all.equal(x, x1)
x <- matrix(a = c(1, 2), b = c(2, 3))
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- c()
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <- sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- c()
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
sum <- 0
for(l in 1:length(thetas)) {
sum <- sum + mat_test[l] * thetas[l]
}
predicted_y[k] <- sum
#  predicted_y[k] <- mat_test %*% thetas
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
# the function returrns the cv error for each fold
basic.cv <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)),]
fold_size <- as.numeric(nrow(sample) / n_folds)
folds <- c()
for (fold in 1:n_folds) {
fold_r = c()
n <- 0
while(n < fold_size) {
fold_r <- c(fold_r, fold)
n <- n + 1
}
folds <- c(folds, fold_r)
}
error_c <- c()
for (i in 1:n_folds) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <-  test_data <- cbind(sample_copy[test_indexes, ],
data.frame(intercept = rep(1, length(test_indexes))))
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[[y_var]])
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- c()
for (k in 1:nrow(test_data)) {
mat_test <- as.matrix(test_data[k, x_vars2])
sum <- 0
for(l in 1:length(thetas)) {
sum <- sum + mat_test[l] * thetas[l]
}
predicted_y[k] <- sum
#  predicted_y[k] <- mat_test %*% thetas
predicted_y[k] <- ifelse(predicted_y[k] > 0.5, 1, 0)
}
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
}
mean(error_c)
}
exam_df_c <- exam_df %>%
dplyr::mutate(test3 = test2 ^ 2)
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x2 <- basic.cv(exam_df_c, c("test1", "test2"), "admitted")
x3 <-  basic.cv(exam_df_c, c("test1"), "admitted")
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
?sapply
predicted_y[k] <- ifelse(mat_test %*% thetas > 0.5, 1, 0)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
library(parallel)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
error_c
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
error_c
unlist(error_c)
mean(unlist(error_c))
x3
library(parallel)
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
basic.cv3 <- function(sample, x_vars, y_var) {
n_folds = 10
set.seed(1)
sample_copy <- sample[sample(nrow(sample)), ]
folds <- cut(seq(1, nrow(sample_copy)), breaks = 10, labels = FALSE)
error_c <- numeric(n_folds)
clusterExport(cl,
c("sample_copy", "folds", "basic.mle",
"J", "h", "g", "H", "grad"),
envir = environment())
error_c <- parLapply(cl, 1:n_folds,
function(i) {
#Segement data by fold
test_indexes <- which(folds == i, arr.ind = TRUE)
test_data <-  sample_copy[test_indexes, ]
train_data <- sample_copy[-test_indexes, ]
# train model using basic.mle
thetas <- basic.mle(train_data[,x_vars], train_data[,y_var])
test_data$intercept <- 1
x_vars2 <- c(x_vars, "intercept")
# use thetas to predict the model in test_data
predicted_y <- numeric(nrow(test_data))
mat_test <- as.matrix(test_data[, x_vars2])
predicted_y <- ifelse(mat_test %*% thetas > 0.5, 1, 0)
# calculate error
wrong <- (predicted_y != test_data[[y_var]])
count_wrong <- sum(wrong)
error_c[i] <- count_wrong/nrow(test_data)
})
mean(unlist(error_c))
on.exit(stopCluster(cl))
}
x <- basic.cv(exam_df_c, c("test1", "test2", "test3"), "admitted")
x3 <- basic.cv3(exam_df_c, c("test1", "test2", "test3"), "admitted")
x3
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
x3 <- basic.cv3(exam_df_c, c("test1", "test2", "test3"), "admitted")
library(parallel)
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
x3 <- basic.cv3(exam_df_c, c("test1", "test2", "test3"), "admitted")
x3
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
source('C:/Users/anama/Desktop/ciorna.R', echo=TRUE)
